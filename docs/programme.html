<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.540">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Enquêtes quantitatives - Programme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Pas de résultats",
    "search-matching-documents-text": "documents trouvés",
    "search-copy-link-title": "Copier le lien vers la recherche",
    "search-hide-matches-text": "Cacher les correspondances additionnelles",
    "search-more-match-text": "correspondance de plus dans ce document",
    "search-more-matches-text": "correspondances de plus dans ce document",
    "search-clear-button-title": "Effacer",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Annuler",
    "search-submit-button-title": "Envoyer",
    "search-label": "Recherche"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Enquêtes quantitatives</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Recherche"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Basculer la navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Accueil</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./programme.html" aria-current="page"> 
<span class="menu-text">Programme</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./faq.html"> 
<span class="menu-text">FAQ</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sur cette page</h2>
   
  <ul>
  <li><a href="#linéaments-du-territoire" id="toc-linéaments-du-territoire" class="nav-link active" data-scroll-target="#linéaments-du-territoire">Linéaments du territoire</a></li>
  <li><a href="#couleurs-du-continu" id="toc-couleurs-du-continu" class="nav-link" data-scroll-target="#couleurs-du-continu">Couleurs du continu</a></li>
  <li><a href="#correspondances" id="toc-correspondances" class="nav-link" data-scroll-target="#correspondances">Correspondances</a></li>
  <li><a href="#styles" id="toc-styles" class="nav-link" data-scroll-target="#styles">Styles</a></li>
  <li><a href="#séquences" id="toc-séquences" class="nav-link" data-scroll-target="#séquences">Séquences</a></li>
  <li><a href="#incertitude" id="toc-incertitude" class="nav-link" data-scroll-target="#incertitude">Incertitude</a></li>
  <li><a href="#indices" id="toc-indices" class="nav-link" data-scroll-target="#indices">Indices</a></li>
  <li><a href="#emboîtements" id="toc-emboîtements" class="nav-link" data-scroll-target="#emboîtements">Emboîtements</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Programme</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="linéaments-du-territoire" class="level1">
<h1>Linéaments du territoire</h1>
<p>Mots clés : cartographie ; format vectoriel ; format raster ; projections ; traces</p>
<p>Un jour vous voudrez faire une carte. Toute simple : la disposition d’un hameau, une scène de crime, le voyage d’un marin des Marquises à Moscou. Trois types d’outils s’offriront à vous : papier-crayon, logiciel spécialisé ou langage de <em>data science</em> généraliste. Nous explorerons cette troisième possibilité, et nous verrons que quelques lignes de code (R, Python ou Julia) suffisent à cartographier un nombre déconcertant de phénomènes. Dans la partie terre à terre du cours, on traitera des sujets suivants. Où trouver des informations géographiques structurées ? Comment les données spatiales sont-elles représentées (modèles vectoriel et raster) ? Quelles transformations peut-on leur faire subir ? Avec quels outils (langages, logiciels, <em>packages</em>) les manipuler ? Trois ouvrages, trois enquêtes, en Mongolie, en Jamaïque et en France, nous serviront de fils rouges. Ils nous poseront des questions non moins intéressantes. Comment représenter les territoires vécus ? Les fonds de cartes font-ils seulement tapisserie ? Comment cartographier l’éphémère, le clandestin ?</p>
</section>
<section id="couleurs-du-continu" class="level1">
<h1>Couleurs du continu</h1>
<p>Mots clés : cartes choroplèthes ; palettes de couleurs ; distribution des données ; discrétisation.</p>
<p>Vous êtes face à un taux, une proportion, un pourcentage, un ratio quelconque, qui varie spatialement. Taux d’abstention, taux de chômage, densité de population. Une carte s’impose. La couleur s’invite. Vous imaginez déjà un camaïeu de bleu, des transitions invisibles qui portent insensiblement l’œil des teintes les plus claires aux plus sombres. C’est d’ailleurs ce que par défaut votre logiciel vous propose. Et c’est une très mauvaise idée. Pour être efficace, votre carte a besoin de discontinuité. Il faudra, sans états d’âme, découper votre variable en tranches, ce qu’on appelle la discrétisation. Selon la distribution de vos données et les objectifs que vous poursuivez, vous pourrez piocher parmi une dizaine d’approches et d’algorithmes. Au cours de cette séance, on parlera également palettes de couleurs, inclusion, données manquantes et valeurs extrêmes. Deux enquêtes nous accompagneront : sur le nuage de Tchernobyl et la vie électorale française.</p>
</section>
<section id="correspondances" class="level1">
<h1>Correspondances</h1>
<p>Mots clés : Analyse des Correspondances Multiples (ACM) ; Classification ascendante hiérarchique (CAH) ; K-means.</p>
<p>Quelle surprise ! Votre questionnaire est un succès. Des milliers de personnes ont accepté de répondre à vos dizaines de questions. Maintenant les ennuis commencent, les tris croisés s’accumulent. Trop, c’est trop, vous voudriez n’avoir posé que deux questions. N’y a-t-il pas un moyen de <em>résumer</em> l’information ? Il y en a plusieurs. D’abord, vous pouvez “réduire la dimensionnalité”, en construisant des variables synthétiques à partir de l’information d’origine. Et puis vous pouvez grouper vos individus, en fonction des réponses qu’ils ont données. Nous verrons comment faire successivement l’un et l’autre, comment interpréter les résultats, et comment les communiquer. Que faire des données manquantes ? Pourquoi faut-il se méfier des modalités peu fréquentes ? Combien de classes choisir pour le partitionnement ? Une enquête sur le premier confinement français animera ces questions techniques.</p>
</section>
<section id="styles" class="level1">
<h1>Styles</h1>
<p>Mots clés : Océrisation ; <em>Handwriting Recognition</em> ; Annotation ; <em>Clustering</em></p>
<p>Autour de vous s’amoncellent des témoignages, des lettres, des journaux intimes. Vous croulez sous une masse d’écrits du for privé. Deux solutions s’offrent à vous : picorer dans cette masse, citer ce qui vous plaît, délaisser ce qui vous dérange ; ou prendre tout, sans distinction, et vous laisser surprendre. Cette séance part d’une enquête sur l’expérience de la Première Guerre Mondiale, à travers les correspondances de paysans, d’ouvriers, d’instituteurs et d’écrivains. La question qu’on se posera est simple : la façon d’écrire la guerre reflète-t-elle la manière de la vivre ? Le style peut-il être une fenêtre sur l’expérience ? Dans la rubrique terre à terre : comment transformer un carton de lettres en base de données ? Comment assigner automatiquement une classe grammaticale à chaque mot d’un texte ? Comment caractériser, par des indicateurs simples, le style d’un scripteur ? Comment organiser les va-et-vient entre lecture immergée et lecture à distance ? Quelles représentations graphiques inventer pour stimuler l’interprétation ?</p>
</section>
<section id="séquences" class="level1">
<h1>Séquences</h1>
<p>Mots clés : Analyse de séquences ; <em>Optimal Matching</em> ; <em>Clustering</em>.</p>
<p>R. est né en 1946. De ses 14 à ses 35 ans, il a travaillé gratuitement sur la ferme familiale. Puis il a été exploitant en titre, jusqu’à sa retraite, à 56 ans. Combien de trajectoires ressemblent à celle de R. ? Cette question est du ressort d’une famille de méthodes, l’analyse de séquences, dont le représentant le plus connu est l’appariement optimal (<em>Optimal Matching</em>). L’unité de base de cette méthode est une séquence, c’est à dire une suite d’éléments ordonnés : une carrière professionnelle, l’emploi du temps d’un jour, une phrase, une danse. Pour calculer la distance entre deux séquences, les algorithmes comptent le nombre minimum d’opérations élémentaires (insertion, suppression, substitution) nécessaires pour passer d’une séquence à l’autre. À partir de la matrice de distances obtenue, il est possible de faire des typologies de séquences. La mise en oeuvre et l’interprétation des résultats avec <em>R</em> est particulièrement simple. L’essentiel des tâtonnements se situe en amont : comment recoder mes données pour que les composantes élémentaires de chaque séquence traduisent le plus précisément possible la question que je me pose ? Quel “coût” assigner à la substitution d’une portion de séquence à une autre ? On explorera ces questions avec deux enquêtes : l’une sur les carrières professionnelles, l’autre sur les emplois du temps.</p>
</section>
<section id="incertitude" class="level1">
<h1>Incertitude</h1>
<p>Mots clés : Bayes ; <em>Prior</em> ; <em>Likelihood</em> ; <em>Posterior</em> ; <em>Markov chain Monte Carlo</em> ; <em>Beta-Binomial model</em> ; <em>Conjugate distributions</em></p>
<p>Au cours de l’année 1961, dans un bâtiment de l’Université de Yale, 26 personnes, sur 40, acceptèrent d’infliger des chocs électriques d’intensité croissante à une personne cardiaque qui les suppliait d’arrêter. Les gémissements étaient pré-enregistrés, les chocs imaginaires. Il s’agissait d’une expérience, qui eût un immense retentissement. Supposons un instant que ces 40 personnes, recrutées dans le Connecticut au début des années 1960, soient représentatives d’un “être humain moyen”. Quelle est la probabilité qu’une personne prise au hasard dans la rue fasse la même chose ? Les statistiques bayésiennes vous autorisent à poser ce genre de questions, et à y répondre précisément. Elles permettent aussi de prendre en compte les informations que vous pouvez avoir par ailleurs, et d’affiner vos croyances au fur et à mesure que vous recueillez davantage d’informations. Intuitive et amusante, cette approche se développe rapidement, et bénéficie d’excellentes implémentations en R, Python et Julia. Dans cette séance, on présente les principes fondamentaux des statistiques bayésiennes, et on introduit, de manière simple et accessible, les Méthodes de Monte Carlo par Chaînes de Markov (en anglais : MCMC).</p>
<p><em>Prérequis :</em> Des connaissances élémentaires en probabilités sont requises pour profiter pleinement de cette séance. Pour les personnes qui en sont dépourvues, il suffira de lire un ou deux chapitres de manuel en amont.</p>
</section>
<section id="indices" class="level1">
<h1>Indices</h1>
<p>Mots clés : Bayes ; <em>Gamma-Poisson model</em> ; <em>Normal-Normal model</em> ; Régression ; Classification.</p>
<p>Vous avez construit un modèle. Il est certainement faux (ils le sont tous). Mais peut-être est-il utile. L’objet de cette séance est de vous donner un certain nombre de clefs pour répondre à ces deux questions : à quel point mon modèle est-il faux ? Sert-il à quelque chose ? Par modèle, on entend ces machines plus ou moins compliquées que les statisticiens fabriquent pour faire des prédictions à partir d’un faisceau d’indices. Les sciences sociales, peu concernées par les prédictions, utilisent plus couramment les modèles pour tester l’existence d’un lien de causalité entre deux phénomènes. On s’appuiera sur la séance précédente pour présenter la version bayésienne de modèles simples, pour des tâches de régression (nombre de personnes qui voteront pour X aux prochaines élections) et de classification (probabilité que X soit élu). On montrera comment évaluer la qualité des prédictions faites par ces modèles.</p>
</section>
<section id="emboîtements" class="level1">
<h1>Emboîtements</h1>
<p>Mots clés : Bayes ; <em>Hierarchichal models</em>.</p>
<p>Toute boîte à outils incomplète vous fait courir un risque : transformer l’or en plomb. Au fondement des modèles statistiques couramment enseignés, il y a une hypothèse forte : vos observations sont indépendantes. Dans la pratique, il arrive fréquemment que cette condition ne se vérifie pas. Et c’est une bonne chose. Les données de panel, par exemple, qui contiennent pour chaque individu de multiples observations, sont d’une grande richesse. En les abordant avec des outils standards, non seulement vous passerez à côté de leur potentiel, mais vous obtiendrez souvent des résultats bizarres ou contre-intuitifs. Fort heureusement, il existe des modèles taillés sur mesure pour ce genre de données. On les appelle, selon les cas : <em>hierarchichal</em>, <em>mixed effects</em>, <em>multilevel</em>, ou <em>random effects models</em>. Le principe en est très simple, les avantages immédiatement visibles. On en présentera de nombreux cas d’application, et on montrera comment les mettre en oeuvre dans un cadre bayésien.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copié");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copié");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>